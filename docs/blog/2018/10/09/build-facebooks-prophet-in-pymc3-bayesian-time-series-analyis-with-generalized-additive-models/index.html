<!DOCTYPE html>
<html lang="en-EN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="keyword 1, keyword 2, keyword 3" name="keywords">
<meta content="Ritchie Vink" name="author">
<meta property="og:title" content="Build Facebook&#39;s Prophet in PyMC3; Bayesian time series analyis with Generalized Additive Models - Ritchie Vink">
<meta property="og:url" content="https://www.ritchievink.com/blog/2018/10/09/build-facebooks-prophet-in-pymc3-bayesian-time-series-analyis-with-generalized-additive-models/">
<meta property="og:description" content="">
<meta property="og:type" content="website" />


<meta property="og:image" content="https://www.ritchievink.com/img/post-19-prophet/head.jpg" />


<title>Build Facebook&#39;s Prophet in PyMC3; Bayesian time series analyis with Generalized Additive Models | Ritchie Vink</title>

<link rel="stylesheet" href="https://www.ritchievink.com//css/style.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<link rel="stylesheet"
      href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/styles/default.min.css">

</head>

<body>
<section class="section">
  <div class="container">
    <nav class="nav">

 <img src="../../../../../profile.jpg" alt="Avatar" style="margin-right: 1em" height="100px"> 
      <div class="nav-left" style="flex-basis: auto;">

        <a class="nav-item" href="https://www.ritchievink.com/"><h1 class="title is-4">Ritchie Vink</h1></a>
      <nav class="nav-item level is-mobile">
          <a class="level-item" href="../../../../../tags">
            tags
          </a>
          
          
          <a class="level-item" href="https://www.ritchievink.com/about/">
            about
          </a>
          
          <a class="level-item" href="https://www.ritchievink.com/anastruct/">
            anastruct
          </a>
          
        </nav>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/ritchie46" target="_blank">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://linkedin.com/in/ritchievink/" target="_blank">
            <span class="icon">
              <i class="fa fa-linkedin-square"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://www.ritchievink.com/index.xml" target="_blank">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">Build Facebook&#39;s Prophet in PyMC3; Bayesian time series analyis with Generalized Additive Models</h1>
    <h2 class="subtitle is-5">October 9, 2018 by Ritchie Vink</h2>
    
      <div class="tags">
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/machine-learning">machine learning</a>
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/python">python</a>
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/algorithm-breakdown">algorithm breakdown</a>
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/time-series">time series</a>
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/pymc3">pymc3</a>
    
        <a class="button is-link" href="https://www.ritchievink.com/tags/bayesian">Bayesian</a>
    
</div>

    
    <div class="content">
      <figure><img src="../../../../../img/post-19-prophet/head.jpg"/>
</figure>

<br>
Last [Algorithm Breakdown](https://www.ritchievink.com/blog/2018/09/26/algorithm-breakdown-ar-ma-and-arima-models/) we build an ARIMA model from scratch and discussed the use cases of that kind of models. ARIMA models are great when you have got stationary data and when you want to predict a few time steps into the future. A lot of business data, being generated by human processes, have got weekly and yearly seasonalities (we for instance, seem work to less in weekends and holidays) and show peaks at certain events. This kind of data is
measured a lot and there is time series expertise needed to model this correctly. Facebook has released an open source tool, Prophet, for analyzing this type of business data. Prophet is able to fit a robust model and makes advanced time series analysis more available for laymen. 
<p>This post we break down the components of Prophet and implement it in PyMC3.</p>
<h2 id="generalized-additive-models">Generalized Additive Models</h2>
<p>Prophet is based on Generalized Additive Models, which is actually nothing more than a fancy name for the summation of the outputs of different models. In Prophets case, it is the summation of a trend $g(t)$, a seasonal series $s(t)$, and a holiday effect (special events) $h(t)$.</p>
<p>$$ y(t) = g(t) + s(t) + h(t) + \epsilon_t \tag{1}$$</p>
<p>$y(t)$ is the time series data we observe at time $t$, and $\epsilon$ is some stochastic process we cannot explain.</p>
<p>With a probabilistic framework such as <a href="http://mc-stan.org/">Stan</a> or <a href="https://docs.pymc.io/">Pymc3</a>, we can define priors on the parameters of terms $g(t)$, $s(t)$, and $h(t)$ and then sample the posterior distribution to find the maximum likelihood of $y(t)$ (observed data). Facebook has implemented this model in probabilistic framework Stan. We are going to implement it in Pymc3. In this post, we will only focus on the terms $g(t)$ and $s(t)$ as that covers the gist of the problem. Implementing $h(t)$ is an easy extension which I leave for the enthusiastic readers.</p>
<h2 id="linear-trend-with-changepoints">Linear Trend with Changepoints</h2>
<p>We will model a piece-wise constant growth described by</p>
<p>$$ g(t) = (k + a(t)^T \delta)t + (m + a(t)^T \gamma) \tag{2}$$</p>
<p>where $k$ is the growth rate, $m$ is the offset parameter, $\delta$ is a vector with growth rate adjustments, and $\gamma_j$ is set to $-s_j \delta_j$, where $s_j$ is a changepoint in time.</p>
<p>This growth model consists of a base trend $k$ and preset changepoints at which the growth rate can be adjusted by $s_j$. Those preset changepoints are defined in a vector with $S$ changepoints at times $s_j$, $j = 1, &hellip;, S$. At each unique changepoint $s_j$, the growth rate is adjusted by $\delta_j$. We can define all growth rate adjustments by the vector $\delta \in \mathbb{R}^S$</p>
<p>The growth rate is adjusted every time step that $t$ surpasses a changepoints $s_j$, the growth rate becomes the base rate plus the sum of all adjustments up to that point</p>
<p>$$ k + \sum_{j: t &gt; s_j} \delta_j \tag{3}$$</p>
<p><strong>Eq (3)</strong> can be vectorized by defining $a(t) \in {0, 1}^S$ such that</p>
<div>$$ 
<p>a(t)=</p>
<p>\begin{cases}
1,              &amp; \text{if } t\geq s_j, \
0,              &amp; \text{otherwise}
\end{cases}</p>
<p>\tag{4}
$$</div></p>
<p>By taking the dot product, all the changepoints $s_j &gt; t$ cancel out. The growth rate at time $t$ is then</p>
<p>$$ k + a(t)^T \delta \tag{5} $$</p>
<p>We can actually rewrite the whole function for all time values $t$ by defining a matrix $A$.</p>
<p>As an example, let $S$ be the changepoints $2, 5, 8$, and time steps $t = 1, 2, \dots, 10$</p>
<div class=formula-wrap>$$ 
<p>A =
\begin{bmatrix}
t_{1} \geq s_1  &amp; t_{1} \geq s_2  &amp; \dots  &amp; t_{1} \geq s_n \
t_{2} \geq s_1  &amp; t_{2} \geq s_2  &amp; \dots  &amp; t_{2} \geq s_n \
\vdots       &amp; \vdots       &amp; \ddots &amp; \vdots      \
t_{k} \geq s1  &amp; t_{k} \geq s_2 &amp; \dots  &amp; t_{k} \geq s_n
\end{bmatrix}</p>
<p>=</p>
<p>\begin{bmatrix}
1 \geq 2     &amp; 1 \geq 5  &amp; 1 \geq 8 \
2 \geq 2     &amp; 2 \geq 5  &amp; 2 \geq 8 \
\vdots       &amp; \vdots    &amp; \vdots   \
10 \geq 2    &amp; 10 \geq 5 &amp; 10 \geq 8
\end{bmatrix}</p>
<p>=</p>
<p>\begin{bmatrix}
0       &amp;  0        &amp; 0 \
1       &amp;  0        &amp; 0 \
\vdots  &amp; \vdots    &amp; \vdots   \
1       &amp;  1        &amp; 1
\end{bmatrix}</p>
<p>$$</div></p>
<p><strong>Eq. (2)</strong> then becomes</p>
<p>$$ \vec{g} = (k + A \vec{\delta}) \odot \vec{t} + (m + A \vec{\gamma}) \tag{6}$$</p>
<p>Let&rsquo;s get a feel for this formula by plotting different components.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># one shot import all we need for this post</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pymc3 <span style="color:#66d9ef">as</span> pm
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy <span style="color:#f92672">import</span> stats
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> theano
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> theano.tensor <span style="color:#66d9ef">as</span> tt
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> fbprophet <span style="color:#f92672">import</span> Prophet
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">25</span>)
</span></span><span style="display:flex;"><span>n_changepoints <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sort(np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice(t, n_changepoints, replace<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> (t[:, <span style="color:#66d9ef">None</span>] <span style="color:#f92672">&gt;</span> s) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>delta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(size<span style="color:#f92672">=</span>n_changepoints)
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>growth <span style="color:#f92672">=</span> (k <span style="color:#f92672">+</span> A <span style="color:#f92672">@</span> delta) <span style="color:#f92672">*</span> t
</span></span><span style="display:flex;"><span>gamma <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>s <span style="color:#f92672">*</span> delta
</span></span><span style="display:flex;"><span>offset <span style="color:#f92672">=</span> m <span style="color:#f92672">+</span> A <span style="color:#f92672">@</span> gamma
</span></span><span style="display:flex;"><span>trend <span style="color:#f92672">=</span> growth <span style="color:#f92672">+</span> offset
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">310</span>
</span></span><span style="display:flex;"><span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t, f <span style="color:#f92672">in</span> zip([<span style="color:#e6db74">&#39;Linear Trend with Changepoints&#39;</span>, <span style="color:#e6db74">&#39;Growth rate&#39;</span>, <span style="color:#e6db74">&#39;Growth offset&#39;</span>],
</span></span><span style="display:flex;"><span>                [trend, growth, offset]):
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>subplot(n <span style="color:#f92672">+</span> i)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>title(t)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>yticks([])
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>vlines(s, min(f), max(f), lw<span style="color:#f92672">=</span><span style="color:#ae81ff">0.8</span>, linestyles<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot(f)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/piecewise-trend.png"/><figcaption>
            <h4>Components of the piecewise linear trend function.</h4>
        </figcaption>
</figure>

<p>Above we see the result of the piecewise linear trend with changepoints. The changepoints are shown by vertical dashed lines. The first plot shows the result of the whole trend function as a reasonable continuous trend. The middle plot shows the growth rate $ k + \sum_{j: t &gt; s_j} \delta_j $ at time $t$. The last plot shows the offset at time $t$. These are just horizontal plateaus that adjust the growth rate&rsquo;s height in order to generate a continuous plot.</p>
<h2 id="trend-model">Trend model</h2>
<p>Let&rsquo;s implement this first part of the model. For some vague reason, the PyMC3&rsquo;s NUTS sampler doesn&rsquo;t work if I use Theano&rsquo;s (the framework in which PyMC3 is implemented) dot product function <code>tt.dot</code>. Therefore we quickly implement our own.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">det_dot</span>(a, b):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    The theano dot product and NUTS sampler don&#39;t work with large matrices?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param a: (np matrix)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param b: (theano vector)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (a <span style="color:#f92672">*</span> b[<span style="color:#66d9ef">None</span>, :])<span style="color:#f92672">.</span>sum(axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><h3 id="data">Data</h3>
<p>Let&rsquo;s also load and prepare some data. We are going to use the same dataset as Facebook does in their <a href="https://facebook.github.io/prophet/docs/quick_start.html">Quick Start</a> tutorial of Prophet. The <em>csv</em> file can be <a href="https://github.com/facebook/prophet/blob/master/examples/example_wp_log_peyton_manning.csv">downloaded here</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#39;peyton_manning.csv&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make sure we work with datetime types</span>
</span></span><span style="display:flex;"><span>df[<span style="color:#e6db74">&#39;ds&#39;</span>] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>to_datetime(df[<span style="color:#e6db74">&#39;ds&#39;</span>])
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Scale the data</span>
</span></span><span style="display:flex;"><span>df[<span style="color:#e6db74">&#39;y_scaled&#39;</span>] <span style="color:#f92672">=</span> df[<span style="color:#e6db74">&#39;y&#39;</span>] <span style="color:#f92672">/</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>df[<span style="color:#e6db74">&#39;t&#39;</span>] <span style="color:#f92672">=</span> (df[<span style="color:#e6db74">&#39;ds&#39;</span>] <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min()) <span style="color:#f92672">/</span> (df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>max() <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min())
</span></span><span style="display:flex;"><span>df<span style="color:#f92672">.</span>plot(x<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ds&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;y&#39;</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">6</span>), title<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Wikipedia pageviews for &#39;Peyton Manning&#39;&#34;</span>)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/manning-ts.png"/><figcaption>
            <h4>Daily pageviews of Peyton Manning&#39;s Wikipedia page.</h4>
        </figcaption>
</figure>

<p>Below we define the PyMC3 implementation of the piecewise linear trend model. The standard model is defined by</p>
<p>$$ k \sim N(0, 5)  $$
$$ \delta \sim Laplace(0, 0.05) $$
$$ m \sim N(0, 5) $$
$$ g|k, \delta, m = (k + A \delta) \odot t + (m + A (-s \odot \delta)) $$
$$ \sigma \sim N(0, 0.5) $$
$$ y| g, \sigma \sim N(g, \sigma) $$</p>
<p>In Python/ PyMC3 this translates to</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">trend_model</span>(m, t, n_changepoints<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>, changepoints_prior_scale<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, 
</span></span><span style="display:flex;"><span>                growth_prior_scale<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>, changepoint_range<span style="color:#f92672">=</span><span style="color:#ae81ff">0.8</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    The piecewise linear trend with changepoint implementation in PyMC3.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param m: (pm.Model)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param t: (np.array) MinMax scaled time.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param n_changepoints: (int) The number of changepoints to model.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param changepoint_prior_scale: (flt/ None) The scale of the Laplace prior on the delta vector.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                    If None, a hierarchical prior is set.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param growth_prior_scale: (flt) The standard deviation of the prior on the growth.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param changepoint_range: (flt) Proportion of history in which trend changepoints will be estimated. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :return g, A, s: (tt.vector, np.array, tt.vector)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, changepoint_range <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>max(t), n_changepoints <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># * 1 casts the boolean to integers</span>
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">=</span> (t[:, <span style="color:#66d9ef">None</span>] <span style="color:#f92672">&gt;</span> s) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># initial growth</span>
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">&#39;k&#39;</span>, <span style="color:#ae81ff">0</span> , growth_prior_scale)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> changepoints_prior_scale <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            changepoints_prior_scale <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Exponential(<span style="color:#e6db74">&#39;tau&#39;</span>, <span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># rate of change</span>
</span></span><span style="display:flex;"><span>        delta <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Laplace(<span style="color:#e6db74">&#39;delta&#39;</span>, <span style="color:#ae81ff">0</span>, changepoints_prior_scale, shape<span style="color:#f92672">=</span>n_changepoints)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># offset</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">&#39;m&#39;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>        gamma <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>s <span style="color:#f92672">*</span> delta
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        g <span style="color:#f92672">=</span> (k <span style="color:#f92672">+</span> det_dot(A, delta)) <span style="color:#f92672">*</span> t <span style="color:#f92672">+</span> (m <span style="color:#f92672">+</span> det_dot(A, gamma))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> g, A, s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate a PyMC3 Model context</span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Model()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>    y, A, s <span style="color:#f92672">=</span> trend_model(m, df[<span style="color:#e6db74">&#39;t&#39;</span>])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sigma <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>HalfCauchy(<span style="color:#e6db74">&#39;sigma&#39;</span>, <span style="color:#ae81ff">0.5</span>, testval<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">&#39;obs&#39;</span>, 
</span></span><span style="display:flex;"><span>                 mu<span style="color:#f92672">=</span>y,
</span></span><span style="display:flex;"><span>                 sd<span style="color:#f92672">=</span>sigma,
</span></span><span style="display:flex;"><span>                 observed<span style="color:#f92672">=</span>df[<span style="color:#e6db74">&#39;y_scaled&#39;</span>])
</span></span></code></pre></div><h3 id="sanity-check">Sanity check</h3>
<p>Before we run the model, let&rsquo;s define a small utility function. This function samples from the prior distribution of the model we defined and plots the expected value given the prior, i.e. the mean, and the standard deviation of the sampled values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sanity_check</span>(m, df):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param m: (pm.Model)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param df: (pd.DataFrame)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Sample from the prior and check of the model is well defined.</span>
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>sample_prior_predictive(model<span style="color:#f92672">=</span>m, vars<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;obs&#39;</span>])[<span style="color:#e6db74">&#39;obs&#39;</span>]
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot(y<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">0</span>), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;mean prior&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>fill_between(np<span style="color:#f92672">.</span>arange(y<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]), <span style="color:#f92672">-</span>y<span style="color:#f92672">.</span>std(<span style="color:#ae81ff">0</span>), y<span style="color:#f92672">.</span>std(<span style="color:#ae81ff">0</span>), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;standard deviation&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot(df[<span style="color:#e6db74">&#39;y_scaled&#39;</span>], label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;true value&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># And run the sanity check</span>
</span></span><span style="display:flex;"><span>sanity_check(m, df)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/sanity-trend.png"/><figcaption>
            <h4>Outputs sampled from the prior distribution of the trend model.</h4>
        </figcaption>
</figure>

<p>Above we see the results of the sanity check. The expected output of the model shows a constant expected value of 0 and a reasonable constant standard deviation of $\pm$ 10. We can see that there is an offset between the <em>true value</em> and the <em>mean prior</em>. By eyeballing it, I would say it is an offset of about 1, which is well covered for in our prior of the offset $m \sim N(0, 5)$, as it assigns plenty probability to $m = 5$. This kind of plots really helps you in parameterizing
your model, and reason about the sanity of your results. If we, for instance, hadn&rsquo;t scaled the time values $t$, the output would have looked like this. Giving a strong indication that our model is not well defined.</p>
<figure><img src="../../../../../img/post-19-prophet/sanity-flawed.png"/><figcaption>
            <h4>Outputs sampled from the prior distribution of the trend model when the input variables $t$ are not scaled.</h4>
        </figcaption>
</figure>

<h3 id="inference">Inference</h3>
<p>Now we are going infer the parameters of our model by doing a <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation">Maximum A Posteriori (MAP)</a> estimation. This is an estimation of the mode of the posterior distribution. This estimation is also just a point estimate distribution, meaning that we will not have any information about the posteriors shape. As the dimensionality of a problem increases, it gets more and more unlikely that the mode equals the region
of highest probability as the mass of the distribution can be situated on a whole different region. The example below shows such a case with a bimodal distribution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>pdf <span style="color:#f92672">=</span> stats<span style="color:#f92672">.</span>norm<span style="color:#f92672">.</span>pdf(x, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> stats<span style="color:#f92672">.</span>norm<span style="color:#f92672">.</span>pdf(x, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0.05</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.06</span>
</span></span><span style="display:flex;"><span>mode <span style="color:#f92672">=</span> pdf<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>mean <span style="color:#f92672">=</span> pdf<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># find the mean of the integrated probablity density function</span>
</span></span><span style="display:flex;"><span>idx_mean <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>argmin(np<span style="color:#f92672">.</span>abs(np<span style="color:#f92672">.</span>cumsum(pdf) <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>cumsum(pdf)<span style="color:#f92672">.</span>mean()))
</span></span><span style="display:flex;"><span>idx_mode <span style="color:#f92672">=</span> pdf<span style="color:#f92672">.</span>argmax()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(x, pdf)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>vlines([x[idx_mean], x[idx_mode]], <span style="color:#ae81ff">0</span>, mode, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">0.8</span>, linestyles<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>annotate(<span style="color:#e6db74">&#39;mean&#39;</span>, (x[idx_mean] <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.2</span>, mode <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.9</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>annotate(<span style="color:#e6db74">&#39;mode&#39;</span>, (x[idx_mode] <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.2</span>, mode <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.9</span>))
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/bimodal.png"/><figcaption>
            <h4>Bimodal distribution, where the mode is in a region with a lower probability mass than the mean.</h4>
        </figcaption>
</figure>

<p>Nonetheless, we are going to estimate the parameters of our model with MAP. Later in this post, we will approximate the posterior distribution by sampling with <a href="https://twiecki.github.io/blog/2015/11/10/mcmc-sampling/">Markov Chain Monte Carlo</a> (MCMC) and look at the benefits this yields.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Find a point estimate of the models parameters</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>    aprox <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>find_MAP()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Determine g, based on the parameters</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">det_trend</span>(k, m, delta, t, s, A):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (k <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(A, delta)) <span style="color:#f92672">*</span> t <span style="color:#f92672">+</span> (m <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(A, (<span style="color:#f92672">-</span>s <span style="color:#f92672">*</span> delta)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># run function and rescale to original scale</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> det_trend(aprox[<span style="color:#e6db74">&#39;k&#39;</span>], aprox[<span style="color:#e6db74">&#39;m&#39;</span>], aprox[<span style="color:#e6db74">&#39;delta&#39;</span>], df[<span style="color:#e6db74">&#39;t&#39;</span>], s, A) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;$g(t)$&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(g)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(np<span style="color:#f92672">.</span>arange(df<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]), df<span style="color:#f92672">.</span>y, s<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;black&#39;</span>)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/g_t.png"/><figcaption>
            <h4>Result of piecewise linear trend with changepoints.</h4>
        </figcaption>
</figure>

<p>Above we see the result of our parameter estimation, which looks pretty reasonable. We see that the model has remained quite a linear trend. This is due to the prior we have set on the changepoint_prior, $\tau = 0.05$. If we would increase this value, the model would have more flexibility and be able to follow the variance better, but as a result, have a higher probability of overfitting to the data.</p>
<h2 id="seasonality">Seasonality</h2>
<p>Of course, we cannot forecast business time series, without modelling seasonalities. Prophet models seasonalities for daily, weekly, monthly and yearly patterns, all based on Fourier series. In this post, we will only focus on weekly and yearly seasonality, but adding more will be easy!</p>
<p>A Fourier series is described by</p>
<p>$$ s(t) = \sum_{n=1}^N(a_n cos(\frac{2\pi nt}{P}) + b_n sin(\frac{2 \pi nt}{P})) \tag{7}$$</p>
<p>Here $P$ is the period we want to model as seasonal effect. For yearly data $P = 365.25$, and for weekly data $P = 7$. $N$ is the order of the Fourier series. Prophet uses $N = 10$ for yearly data and $N = 3$ for weekly data. We can generate a matrix $X(t)$ containing parts of <strong>eq. (7)</strong> for each value of $t$. With weekly data, this will result in</p>
<p>$$ X(t) = [cos( \frac{2\pi 1t}{7}), &hellip;, sin(\frac{2\pi 3t}{7})] \tag{8}$$</p>
<p>Our model should then have parameters $\beta \in \mathbb{R}^{2N}$, $\beta = a_1, b_1, &hellip;, a_n, b_n$.</p>
<p>The seasonal component is then</p>
<p>$$ s(t) = X(t) \beta \tag{9}$$</p>
<p>Let&rsquo;s define the matrix $X(t)$ in Python and test the result with a randomly initialized vector $\beta$.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fourier_series</span>(t, p<span style="color:#f92672">=</span><span style="color:#ae81ff">365.25</span>, n<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 2 pi n / p</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>pi <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> p
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 2 pi n / p * t</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> t[:, <span style="color:#66d9ef">None</span>]
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate((np<span style="color:#f92672">.</span>cos(x), np<span style="color:#f92672">.</span>sin(x)), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>beta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(size<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(fourier_series(t, <span style="color:#ae81ff">365.25</span>, n) <span style="color:#f92672">@</span> beta)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/fourier.png"/><figcaption>
            <h4>Example of a Fourier series with order 4 and a period of 365.25.</h4>
        </figcaption>
</figure>

<h2 id="complete-model">Complete model</h2>
<p>Now we&rsquo;ve set up all we need for our complete model. We mentioned earlier that Prophet, estimates a maximum point estimate of the posterior distribution. We are going to sample in order to estimate the posterior. By sampling, we are will not find values for our parameters, but find whole distributions! This is great! We will have a lot of information about the uncertainty of our predictions by analyzing the posterior distributions, or by just sampling the posterior! I think this is
very cool, and see this as one of the best properties of Bayesian modeling.</p>
<p>Different from the base model, we will now set a hierarchical prior on the changepoint_prior_scale $\tau$. In the base model, this was set to $\tau = 0.05$. This base prior is pretty restrictive, giving the model not too much flexibility to fit the data. Because we will not restrict the model as much, we probably have a trend that is more able to fit the data.</p>
<p>The complete model is now defined as</p>
<p>$$ k \sim N(0, 5)  $$
$$ \tau \sim Exponential(1.5) $$
$$ \delta| \tau \sim Laplace(0, \tau) $$
$$ m \sim N(0, 5) $$
$$ g|k, \delta, m, \tau = (k + A \delta) \odot t + (m + A (-s \odot \delta)) $$
$$ \beta \sim N(0, 10) $$
$$ s| \beta = X(t) \beta $$
$$ \sigma \sim HalfCauchy(0, 0.5) $$
$$ y| g, \sigma, s \sim N(g + s, \sigma) $$</p>
<p>Below we build the model defined above. First, we define a function <code>seasonality_model</code> which initiates the priors $\beta$ for seasonality regression. Note that we MinMax scale the period of the Fourier series, as $t$ is also MinMax scaled. The prior output is defined by</p>
<p>$$ y(t) = g(t) + s(t)_{weekly} + s(t)_{yearly} + \epsilon_t \tag{10}$$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">seasonality_model</span>(m, df, period<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;yearly&#39;</span>, seasonality_prior_scale<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> period <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;yearly&#39;</span>:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># rescale the period, as t is also scaled</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> <span style="color:#ae81ff">365.25</span> <span style="color:#f92672">/</span> (df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>max() <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min())<span style="color:#f92672">.</span>days
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:  <span style="color:#75715e"># weekly</span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># rescale the period, as t is also scaled</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">/</span> (df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>max() <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min())<span style="color:#f92672">.</span>days
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> fourier_series(df[<span style="color:#e6db74">&#39;t&#39;</span>], p, n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>        beta <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;beta_</span><span style="color:#e6db74">{</span>period<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>, mu<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, sd<span style="color:#f92672">=</span>seasonality_prior_scale, shape<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x, beta
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Model()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># changepoints_prior_scale is None, so the exponential distribution</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># will be used as prior on \tau.</span>
</span></span><span style="display:flex;"><span>    y, A, s <span style="color:#f92672">=</span> trend_model(m, df[<span style="color:#e6db74">&#39;t&#39;</span>], changepoints_prior_scale<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>    x_yearly, beta_yearly <span style="color:#f92672">=</span> seasonality_model(m, df, <span style="color:#e6db74">&#39;yearly&#39;</span>)
</span></span><span style="display:flex;"><span>    x_weekly, beta_weekly <span style="color:#f92672">=</span> seasonality_model(m, df, <span style="color:#e6db74">&#39;weekly&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">+=</span> det_dot(x_yearly, beta_yearly) <span style="color:#f92672">+</span> det_dot(x_weekly, beta_weekly)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sigma <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>HalfCauchy(<span style="color:#e6db74">&#39;sigma&#39;</span>, <span style="color:#ae81ff">0.5</span>, testval<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    obs <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">&#39;obs&#39;</span>, 
</span></span><span style="display:flex;"><span>                 mu<span style="color:#f92672">=</span>y, 
</span></span><span style="display:flex;"><span>                 sd<span style="color:#f92672">=</span>sigma,
</span></span><span style="display:flex;"><span>                 observed<span style="color:#f92672">=</span>df[<span style="color:#e6db74">&#39;y_scaled&#39;</span>])
</span></span></code></pre></div><p>And we start MCMC sampling by</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">with</span> m:
</span></span><span style="display:flex;"><span>    trace <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>sample(<span style="color:#ae81ff">500</span>)
</span></span><span style="display:flex;"><span>pm<span style="color:#f92672">.</span>traceplot(trace)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/param-dis.png"/><figcaption>
            <h4>Posterior parameter distribution.</h4>
        </figcaption>
</figure>

<p>Above we see the result of our MCMC sampling. We have found an estimate of the posterior distribution of our parameters. Now that we have got this, we can take a look at how the model has fit the data. Below we are computing the trend and the seasonalities for all the drawn samples. This will result in a matrix of shape $T \times S$, with $T$ being the number of data points and $S$ the number of drawn samples. With this matrix, we can finally compute the credible intervals of
our fit. Below is the plot shown with credible intervals of 95%.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">det_seasonality_posterior</span>(beta, x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>dot(x, beta<span style="color:#f92672">.</span>T)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.025</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># vector distributions</span>
</span></span><span style="display:flex;"><span>beta_yearly <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;beta_yearly&#39;</span>]
</span></span><span style="display:flex;"><span>beta_weekly <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;beta_weekly&#39;</span>]
</span></span><span style="display:flex;"><span>delta <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;delta&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># scalar distributions</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;k&#39;</span>]
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;m&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># determine the posterior by evaulating all the values in the trace.</span>
</span></span><span style="display:flex;"><span>trend_posterior <span style="color:#f92672">=</span> ((k <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(A, delta<span style="color:#f92672">.</span>T)) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;t&#39;</span>][:, <span style="color:#66d9ef">None</span>] <span style="color:#f92672">+</span> m <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(A, (<span style="color:#f92672">-</span>s <span style="color:#f92672">*</span> delta)<span style="color:#f92672">.</span>T)) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>yearly_posterior <span style="color:#f92672">=</span> det_seasonality_posterior(beta_yearly, x_yearly) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>weekly_posterior <span style="color:#f92672">=</span> det_seasonality_posterior(beta_weekly, x_weekly) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>date <span style="color:#f92672">=</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>dt<span style="color:#f92672">.</span>to_pydatetime()
</span></span><span style="display:flex;"><span>sunday <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>argmax(df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>dt<span style="color:#f92672">.</span>dayofweek)
</span></span><span style="display:flex;"><span>weekdays <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;sunday&#39;</span>, <span style="color:#e6db74">&#39;monday&#39;</span>, <span style="color:#e6db74">&#39;tuesday&#39;</span>, <span style="color:#e6db74">&#39;wednesday&#39;</span>, <span style="color:#e6db74">&#39;thursday&#39;</span>, <span style="color:#e6db74">&#39;friday&#39;</span>, <span style="color:#e6db74">&#39;saturday&#39;</span>]
</span></span><span style="display:flex;"><span>idx_year <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>argmax(df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>dt<span style="color:#f92672">.</span>dayofyear)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> <span style="color:#ae81ff">411</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(b)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;total&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(date,
</span></span><span style="display:flex;"><span>         (trend_posterior <span style="color:#f92672">+</span> yearly_posterior <span style="color:#f92672">+</span> weekly_posterior)<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">1</span>), lw<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(date, df[<span style="color:#e6db74">&#39;y&#39;</span>], s<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;black&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(b <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;trend&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(date, trend_posterior<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>quant <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(trend_posterior, [p, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>fill_between(date, quant[<span style="color:#ae81ff">0</span>, :], quant[<span style="color:#ae81ff">1</span>, :], alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(b <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;yearly&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(date[idx_year: idx_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">365</span>], yearly_posterior<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">1</span>)[idx_year: idx_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">365</span>])
</span></span><span style="display:flex;"><span>quant <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(yearly_posterior, [p, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>fill_between(date[idx_year: idx_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">365</span>],
</span></span><span style="display:flex;"><span>                 quant[<span style="color:#ae81ff">0</span>, idx_year: idx_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">365</span>], quant[<span style="color:#ae81ff">1</span>, idx_year: idx_year <span style="color:#f92672">+</span> <span style="color:#ae81ff">365</span>], alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(b <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;weekly&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(weekdays, weekly_posterior<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">1</span>)[sunday: sunday <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>])
</span></span><span style="display:flex;"><span>quant <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(weekly_posterior, [p, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>fill_between(weekdays, quant[<span style="color:#ae81ff">0</span>, sunday: sunday <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>],
</span></span><span style="display:flex;"><span>                 quant[<span style="color:#ae81ff">1</span>, sunday: sunday <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>], alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/fit.png"/><figcaption>
            <h4>Fitted model with 95% credible intervals.</h4>
        </figcaption>
</figure>

<h2 id="trend-forecasts-and-uncertainty">Trend forecasts and uncertainty</h2>
<p>The uncertainty of the predictions you make in Prophet is determined by the number of changepoints that are allowed, whilst fitting the training data and the flexibility of the changepoint adjustments $\delta$. Intuitively, it says that if we have seen a lot of change in the time history, we can expect a lot of change in the future.</p>
<p>The uncertainty is modeled by sampling changepoints and change adjustments following the rule</p>
<div>$$ 
<p>\forall j &gt; T,</p>
<p>\begin{cases}
\delta_j = 0 \quad w.p. \frac{T - S}{T} \
\delta_j \sim Laplace(0, \lambda) \quad w.p. \frac{S}{T}
\end{cases}</p>
<p>\tag{11}
$$</div></p>
<p>where $T$ is the complete history, and $S$ are the number of changepoints fitted in the training data. For all time steps larger than $T$ there is a probability of occurring a new changepoint $\delta_j$, which is sampled from a Laplace distribution. The scale $\lambda$ of the Laplace distribution is determined by one of the following.</p>
<ul>
<li>The mean of the posterior of the hyperprior $\tau$</li>
<li>If the hyperprior is not set, $\lambda = \frac{1}{S} \sum_{j=1}^S |\delta_j|$.</li>
</ul>
<p>Below we implement a trend forecast and the uncertainty as defined above. We continue with the trace of our earlier sampled model. Because we have defined a hyperprior $\tau$ we can use that as scale parameter $\lambda$ for the Laplace distribution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n_samples <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>days <span style="color:#f92672">=</span> <span style="color:#ae81ff">150</span>
</span></span><span style="display:flex;"><span>history_points <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>probability_changepoint <span style="color:#f92672">=</span> n_changepoints <span style="color:#f92672">/</span> history_points
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>future <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame({<span style="color:#e6db74">&#39;ds&#39;</span>: pd<span style="color:#f92672">.</span>date_range(df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min(), 
</span></span><span style="display:flex;"><span>                                           df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>max() <span style="color:#f92672">+</span> pd<span style="color:#f92672">.</span>Timedelta(days, <span style="color:#e6db74">&#39;D&#39;</span>), 
</span></span><span style="display:flex;"><span>                        df<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> days)})
</span></span><span style="display:flex;"><span>future[<span style="color:#e6db74">&#39;t&#39;</span>] <span style="color:#f92672">=</span> (future[<span style="color:#e6db74">&#39;ds&#39;</span>] <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min()) <span style="color:#f92672">/</span> (df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>max() <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>min())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># vector distributions</span>
</span></span><span style="display:flex;"><span>beta_yearly <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;beta_yearly&#39;</span>]<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>beta_weekly <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;beta_weekly&#39;</span>]<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>delta <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;delta&#39;</span>]<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># scalar distributions</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;k&#39;</span>]<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;m&#39;</span>]<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>trend_forecast <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>lambda_ <span style="color:#f92672">=</span> trace[<span style="color:#e6db74">&#39;tau&#39;</span>]<span style="color:#f92672">.</span>mean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(n_samples):
</span></span><span style="display:flex;"><span>    new_changepoints <span style="color:#f92672">=</span> future[<span style="color:#e6db74">&#39;t&#39;</span>][future[<span style="color:#e6db74">&#39;t&#39;</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>values
</span></span><span style="display:flex;"><span>    sample <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>random(new_changepoints<span style="color:#f92672">.</span>shape)
</span></span><span style="display:flex;"><span>    new_changepoints <span style="color:#f92672">=</span> new_changepoints[sample <span style="color:#f92672">&lt;=</span> probability_changepoint]
</span></span><span style="display:flex;"><span>    new_delta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>r_[delta, 
</span></span><span style="display:flex;"><span>                      stats<span style="color:#f92672">.</span>laplace(<span style="color:#ae81ff">0</span>, lambda_)<span style="color:#f92672">.</span>rvs(new_changepoints<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])]
</span></span><span style="display:flex;"><span>    new_s <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>r_[s, new_changepoints]
</span></span><span style="display:flex;"><span>    new_A <span style="color:#f92672">=</span> (future[<span style="color:#e6db74">&#39;t&#39;</span>][:, <span style="color:#66d9ef">None</span>] <span style="color:#f92672">&gt;</span> new_s) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    trend_forecast<span style="color:#f92672">.</span>append(((k <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(new_A, new_delta)) <span style="color:#f92672">*</span> future[<span style="color:#e6db74">&#39;t&#39;</span>]  <span style="color:#f92672">+</span> (m <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>dot(new_A, (<span style="color:#f92672">-</span>new_s <span style="color:#f92672">*</span> new_delta)))) <span style="color:#f92672">*</span> df[<span style="color:#e6db74">&#39;y&#39;</span>]<span style="color:#f92672">.</span>max())
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>trend_forecast <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(trend_forecast)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>date <span style="color:#f92672">=</span> future[<span style="color:#e6db74">&#39;ds&#39;</span>]<span style="color:#f92672">.</span>dt<span style="color:#f92672">.</span>to_pydatetime()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;Trend forecasts uncertainty&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(date, trend_forecast<span style="color:#f92672">.</span>mean(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>quant <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(trend_forecast, [<span style="color:#ae81ff">0.025</span>, <span style="color:#ae81ff">0.975</span>], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>fill_between(date, quant[<span style="color:#ae81ff">0</span>, :], quant[<span style="color:#ae81ff">1</span>, :], alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.25</span>)
</span></span></code></pre></div><figure><img src="../../../../../img/post-19-prophet/forecast.png"/><figcaption>
            <h4>Trend forecast with 95% credible intervals.</h4>
        </figcaption>
</figure>

<p>Above we see the result of 1000 samples. Due to the flexibility of the hyperprior $\tau$ the model was able to fit the data very well. However by doing so the variance of the changepoints adjustments $\delta$ is quite high, resulting in wide uncertainty bands.</p>
<h2 id="final-words">Final words</h2>
<p>The last model we set a hyperprior on $\tau$. If we don&rsquo;t set this hyperprior and instead and use the <code>changepoint_scale_prior = 0.05</code> we get exactly the same results as Facebook Prophet gets in their Quick Start tutorial. The Prophet implementation comes with more features than we discussed in this post. Their implementation also has an option to model recurring events, (they call them holidays). With the base of this model ready, it is fairly easy to add another linear model that is dependent on other
predictors like the weather. Facebook writes in the introduction of their paper, that Prophet is a good plug and play library for business analysts to do time series analysis. Besides that, it is a very good Bayesian base model to further implement while modeling time series.</p>
<p>Want to read more Algorithm Breakdowns?</p>
<ul>
<li><a href="https://www.ritchievink.com/blog/2018/09/26/algorithm-breakdown-ar-ma-and-arima-models/">ARIMA</a></li>
<li><a href="https://www.ritchievink.com/blog/2017/11/27/implementing-a-support-vector-machine-in-scala/">Support Vector Machines</a></li>
<li><a href="https://www.ritchievink.com/blog/2018/05/18/algorithm-breakdown-affinity-propagation/">Affinity propagation</a></li>
<li><a href="https://www.ritchievink.com/blog/2017/07/10/programming-a-neural-network-from-scratch/">Multilayer perceptrons</a></li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<head>
<style>

.formula-wrap {
overflow-x: scroll;
}

</style>
</head>

    </div>
    
    
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'www-ritchievink-com';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>(c) 2020 Ritchie Vink.</p>
  </div>
</section>

<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.2.0/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script type="text/javascript">
    if (window.location.href.indexOf('localhost') < 0) {
	    var _gaq = _gaq || [];
	    _gaq.push(['_setAccount', 'UA-83196691-2']);
	    _gaq.push(['_trackPageview']);

	    (function() {
		var ga = document.createElement('script');
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
		    'http://www') + '.google-analytics.com/ga.js';
		ga.setAttribute('async', 'true');
		document.documentElement.firstChild.appendChild(ga);
	    })();
}
</script>




</body>
